/**
 * @namespace qtoggle.api.base
 */

import Logger from '$qui/lib/logger.module.js'

import {gettext}           from '$qui/base/i18n.js'
import Config              from '$qui/config.js'
import * as AJAX           from '$qui/utils/ajax.js'
import * as Crypto         from '$qui/utils/crypto.js'
import * as ObjectUtils    from '$qui/utils/object.js'
import * as PromiseUtils   from '$qui/utils/promise.js'
import * as StringUtils    from '$qui/utils/string.js'

import * as Cache from '$app/cache.js'
import * as Utils from '$app/utils.js'

import * as AuthAPI          from './auth.js'
import * as NotificationsAPI from './notifications.js'


const QTOGGLE_API_PREFIX = '/api'

const KNOWN_ERRORS = [
    /* HTTP 400 */
    {
        status: 400,
        rex: new RegExp('^malformed request$'),
        pretty: StringUtils.formatPercent(
            gettext('Communication protocol error (%(error)s).'),
            {error: 'malformed request'}
        )
    },
    {
        status: 400,
        rex: new RegExp('^malformed body'),
        pretty: StringUtils.formatPercent(
            gettext('Communication protocol error (%(error)s).'),
            {error: 'malformed body'}
        )
    },
    {
        status: 400,
        rex: new RegExp('^missing field: (\\w+)$'),
        pretty: StringUtils.formatPercent(
            gettext('Communication protocol error (%(error)s).'),
            {error: 'missing field "$1"'}
        )
    },
    {
        status: 400,
        rex: new RegExp('^invalid request$'),
        pretty: StringUtils.formatPercent(
            gettext('Communication protocol error (%(error)s).'),
            {error: 'invalid request'}
        )
    },
    {
        status: 400,
        rex: new RegExp('^attribute not modifiable: (\\w+)$'),
        pretty: StringUtils.formatPercent(gettext('Attribute "%(attr)s" is not modifiable.'), {attr: '$1'})
    },
    {
        status: 400,
        rex: new RegExp('^no such attribute: (\\w+)$'),
        pretty: StringUtils.formatPercent(gettext('No such attribute "%(attr)s".'), {attr: '$1'})
    },
    {
        status: 400,
        rex: new RegExp('^invalid field: (\\w+)$'),
        pretty: StringUtils.formatPercent(gettext('Invalid value for "%(field)s".'), {field: '$1'})
    },
    {
        status: 400,
        rex: new RegExp('^invalid value$'),
        pretty: gettext('Invalid port value.')
    },
    {
        status: 400,
        rex: new RegExp('^no such version$'),
        pretty: gettext('Firmware version not available.')
    },
    {
        status: 400,
        rex: new RegExp('^duplicate port$'),
        pretty: gettext('The port already exists.')
    },
    {
        status: 400,
        rex: new RegExp('^too many ports$'),
        pretty: gettext('The maximum number of ports has been reached.')
    },
    {
        status: 400,
        rex: new RegExp('^port not removable$'),
        pretty: gettext('Ports that are not virtual cannot be removed.')
    },
    {
        status: 400,
        rex: new RegExp('^port disabled$'),
        pretty: gettext('Requested operation needs the port to be enabled.')
    },
    {
        status: 400,
        rex: new RegExp('^read-only port$'),
        pretty: gettext('Requested operation needs the port to be writable.')
    },
    {
        status: 400, /* Generated by slave devices */
        rex: new RegExp('^forbidden$'),
        pretty: gettext('The supplied credentials are incorrect.')
    },
    {
        status: 400,
        rex: new RegExp('^duplicate device$'),
        pretty: gettext('The device has already been added to master.')
    },
    {
        status: 400,
        rex: new RegExp('^no listen support$'),
        pretty: gettext('The device does not support listening.')
    },
    {
        status: 400,
        rex: new RegExp('^listening and polling$'),
        pretty: gettext('Listening and polling cannot be both enabled.')
    },

    /* HTTP 401 */
    {
        status: 401,
        rex: new RegExp('^authentication required$'),
        pretty: gettext('Credentials are required.')
    },

    /* HTTP 403 */
    {
        status: 403,
        rex: new RegExp('^forbidden$'),
        pretty: gettext('The supplied credentials are incorrect.')
    },

    /* HTTP 404 */
    {
        status: 404,
        rex: new RegExp('^no such port$'),
        pretty: gettext('Requested port does not exist.')
    },
    {
        status: 404,
        rex: new RegExp('^no such function$'),
        pretty: gettext("Device doesn't expose the qToggle API at given URL.")
    },
    {
        status: 404,
        rex: new RegExp('^no such device$'),
        pretty: gettext('Requested device does not exist.')
    },
    {
        status: 404,
        rex: new RegExp('^device disabled$'),
        pretty: gettext('Requested device is disabled.')
    },

    /* HTTP 502 */
    {
        status: 502,
        rex: new RegExp('^port error: (\\w+)$'),
        pretty: StringUtils.formatPercent(gettext('Port communication error: %(error)s.'), {error: '$1'})
    },
    {
        status: 502,
        rex: new RegExp('^invalid device$'),
        pretty: gettext('The device is not a qToggle device.')
    },
    {
        status: 502,
        rex: new RegExp('^connection refused$'),
        pretty: gettext('Device refuses the connection.')
    },
    {
        status: 502,
        rex: new RegExp('^unreachable$'),
        pretty: gettext('Device is unreachable.')
    },

    /* HTTP 503 */
    {
        status: 503,
        rex: new RegExp('^busy$'),
        pretty: gettext('Device is busy.')
    },
    {
        status: 503,
        rex: new RegExp('^device offline$'),
        pretty: gettext('Device is offline.')
    },

    /* HTTP 504 */
    {
        status: 504,
        rex: new RegExp('^port timeout$'),
        pretty: gettext('Timeout while communicating with the port.')
    },
    {
        status: 504,
        rex: new RegExp('^device timeout$'),
        pretty: gettext('Timeout waiting for a response from the device.')
    },

    /* Other errors */
    {
        rex: new RegExp('^timeout$'),
        pretty: gettext('Timeout waiting for a response from the device.')
    },
    {
        rex: new RegExp('^other error: (.*)$'),
        pretty: StringUtils.formatPercent(gettext('Error communicating with device (%(error)s).'), {error: '$1'})
    }
]

const logger = Logger.get('qtoggle.api.base')

/**
 * @alias qtoggle.api.base.DEBUG_API_CALLS
 * @type {Boolean}
 */
export const DEBUG_API_CALLS = false

/**
 * Server request retry interval, in seconds.
 * @alias qtoggle.api.SERVER_RETRY_INTERVAL
 * @type {Number}
 */
export const SERVER_RETRY_INTERVAL = 3

/**
 * Default server request timeout, in seconds.
 * @alias qtoggle.api.DEFAULT_SERVER_TIMEOUT
 * @type {Number}
 */
export const DEFAULT_SERVER_TIMEOUT = 10

/**
 * Server request timeout for requests that take longer time to process, in seconds.
 * @alias qtoggle.api.LONG_SERVER_TIMEOUT
 * @type {Number}
 */
export const LONG_SERVER_TIMEOUT = 60


let slaveName = null
let apiURLPrefix = ''
let syncBeginCallbacks = []
let syncEndCallbacks = []


/**
 * An API error.
 * @alias qtoggle.api.base.APIError
 */
export class APIError extends Error {

    /**
     * @constructs
     * @param {String} messageCode
     * @param {Number} status
     * @param {String} [pretty]
     * @param {?Object} [knownError]
     * @param {*[]}params
     */
    constructor({messageCode, status, pretty = '', knownError = null, params = []}) {
        super(pretty)

        this.messageCode = messageCode
        this.status = status
        this.pretty = pretty
        this.knownError = knownError
        this.params = params
    }

}

function parseAPIErrorMessage(status, message) {
    let parsed = null

    /* Messages starting with "other error: " may encapsulate themselves a known error;
     * we therefore pass the remaining part of the message through the parsing function again */
    let match = message.match(new RegExp('^other error: (.*)$'))
    if (match) {
        parsed = parseAPIErrorMessage(status, match[1])
        if (parsed) {
            return parsed
        }
    }

    KNOWN_ERRORS.some(function (e) {
        let match = message.match(e.rex)
        if (match && (!e.status || e.status === status)) {
            e = ObjectUtils.copy(e, /* deep = */ true)
            match.forEach(function (m, i) {
                if (i === 0) {
                    return /* Skip global group */
                }
                /* This allows no more than 9 match groups! */
                e.pretty = StringUtils.replaceAll(e.pretty, `$${i}`, m)
            })
            e.params = match.slice(1)
            parsed = e

            return true
        }
    })

    return parsed
}

function makeRequestJWT(username, passwordHash) {
    let jwtHeader = {typ: 'JWT', alg: 'HS256'}
    let jwtPayload = {
        usr: username,
        iat: Math.round(new Date().getTime() / 1000),
        ori: 'consumer',
        iss: 'qToggle'
    }
    let jwtHeaderStr = Crypto.str2b64(JSON.stringify(jwtHeader))
    let jwtPayloadStr = Crypto.str2b64(JSON.stringify(jwtPayload))
    let jwtSigningString = `${jwtHeaderStr}.${jwtPayloadStr}`
    let jwtSignature = new Crypto.HMACSHA256(passwordHash, jwtSigningString).digest()
    let jwtSignatureStr = Crypto.str2b64(Crypto.arr2str(jwtSignature))

    return `${jwtSigningString}.${jwtSignatureStr}`
}


/**
 * Create an API error from an HTTP response fields.
 * @alias qtoggle.api.base.makeAPIError
 * @param {Object} data response data
 * @param {Number} status response HTTP status
 * @param {String} msg response message
 * @returns {qtoggle.api.base.APIError}
 */
export function makeAPIError(data, status, msg) {
    let messageCode = data.error || msg
    let prettyMessage = messageCode
    let knownError = null
    let params = null

    let matchedAPIError = null
    if (data.error) {
        matchedAPIError = parseAPIErrorMessage(status, data.error)
        if (matchedAPIError) {
            prettyMessage = matchedAPIError.pretty
            knownError = matchedAPIError
            params = matchedAPIError.params
        }
    }

    if (status === 403) {
        let level = AuthAPI.ACCESS_LEVEL_MAPPING[data['required_level']]
        switch (level) {
            case AuthAPI.ACCESS_LEVEL_ADMIN:
                prettyMessage = gettext('Administrator access level required.')
                break

            case AuthAPI.ACCESS_LEVEL_NORMAL:
                prettyMessage = gettext('Normal access level required.')
                break

            case AuthAPI.ACCESS_LEVEL_VIEWONLY:
                prettyMessage = gettext('View-only access level required.')
                break
        }
    }
    if (status === 500 && data && data.error) {
        /* Internal server error */
        prettyMessage = data.error
    }
    else if (status === 503 && data && data.error === 'busy') {
        prettyMessage = gettext('The device is busy.')
    }
    else if (status === 0) {
        if (msg === 'timeout') {
            prettyMessage = gettext('Timeout waiting for a response from the server.')
        }
        else { /* Assuming disconnected */
            messageCode = 'disconnected'
            prettyMessage = gettext('Connection with the server was lost.')
        }
    }
    else if (!prettyMessage) { /* Unexpected error */
        prettyMessage = gettext('Unexpected error while communicating with the server.')
    }

    return new APIError({
        messageCode: messageCode,
        status: status,
        pretty: prettyMessage,
        knownError: knownError,
        params: params
    })
}

/**
 * Call an API function.
 * @alias qtoggle.api.base.apiCall
 * @param {String} method the method
 * @param {String} path the path (URI)
 * @param {?Object} [query] optional query arguments
 * @param {?Object} [data] optional data (body)
 * @param {?Number} [timeout] timeout, in seconds
 * @param {?Number} [expectedHandle] the handle of the expected event
 * @param {Boolean} [handleErrors] set to `false` to prevent error handling (defaults to `true`)
 * @returns {Promise} a promise that is resolved when the API call succeeds and rejected when it fails; the resolve
 * argument is the result returned by the API call, while the reject argument is the API call error
 */
export function apiCall({
    method, path, query = null, data = null, timeout = DEFAULT_SERVER_TIMEOUT, expectedHandle = null,
    handleErrors = true
}) {

    let params = {method, path, query, data, timeout, slaveName}

    return new Promise(function (resolve, reject) {
        let apiFuncPath = path

        if (slaveName) { /* Slave qToggle API call */
            path = `/devices/${slaveName}/forward${path}`
            slaveName = null
        }

        path = QTOGGLE_API_PREFIX + path

        let isListen = apiFuncPath.startsWith('/listen')
        if (apiURLPrefix) {
            path = apiURLPrefix + path
        }

        if (method === 'POST' || method === 'PATCH' || method === 'PUT') {
            if (DEBUG_API_CALLS && data != null) {
                let bodyStr = JSON.stringify(data, null, 4).replace(new RegExp('\\n', 'g'), '\n   ')
                logger.debug(`call "${method} ${apiFuncPath}":\n    ${bodyStr}`)
            }
            else {
                logger.debug(`call "${method} ${apiFuncPath}"`)
            }
        }
        else {
            data = null
            logger.debug(`call "${method} ${apiFuncPath}"`)
        }

        query = query || {}

        function resolveWrapper(data) {
            if (!isListen) {
                syncEndCallbacks.forEach(c => PromiseUtils.asap().then(() => c(/* error = */ null, params)))
            }

            if (DEBUG_API_CALLS && data != null) {
                let bodyStr = JSON.stringify(data, null, 4).replace(new RegExp('\\n', 'g'), '\n   ')
                logger.debug(`response for "${method} ${apiFuncPath}": \n    ${bodyStr}`)
            }
            else {
                logger.debug(`response for "${method} ${apiFuncPath}"`)
            }

            Utils.resolveJSONRefs(data)

            resolve(data)
        }

        function rejectWrapper(data, status, msg) {
            let error = makeAPIError(data, status, msg)

            if (expectedHandle) {
                NotificationsAPI.unexpectEvent(expectedHandle)
            }

            if (handleErrors) {
                logger.error(`ajax error: ${error} (messageCode="${error.messageCode}", status=${error.status})`)
            }

            reject(error)

            if (!isListen) {
                syncEndCallbacks.forEach(c => PromiseUtils.asap().then(() => c(handleErrors ? error : null, params)))
            }
        }

        /* Compose the JWT authorization header */
        let headers = {}
        let username = AuthAPI.getUsername()
        let passwordHash = AuthAPI.getPasswordHash()
        if (username && passwordHash) {
            headers['Authorization'] = `Bearer ${makeRequestJWT(username, passwordHash)}`
        }

        if (!isListen) {
            syncBeginCallbacks.forEach(c => PromiseUtils.asap().then(() => c(params)))
        }

        AJAX.requestJSON(
            method, path, query, data,
            /* success = */ function (data, headers) {

                resolveWrapper(data)

            },
            /* failure = */ function (data, status, msg, headers) {

                rejectWrapper(data, status, msg)

            },
            headers, timeout
        )
    })
}

/**
 * API request indication callback function.
 * @callback qtoggle.api.base.SyncBeginCallback
 * @param {Object} params API call parameters
 */

/**
 * API response indication callback function.
 * @callback qtoggle.api.base.SyncEndCallback
 * @param {?qtoggle.api.base.APIError} [error] indicates an error occurred during request
 * @param {Object} params API call parameters
 */

/**
 * Add a set of functions to be called each time an API request is initiated and responded.
 * @alias qtoggle.api.base.addSyncCallbacks
 * @param {qtoggle.api.base.SyncBeginCallback} [beginCallback] a function to be called at the initiation of each API
 * request
 * @param {qtoggle.api.SyncEndCallback} [endCallback] a function to be called at the end of each API request (when the
 * response is received or an error occurs)
 */
export function addSyncCallbacks(beginCallback = null, endCallback = null) {
    if (beginCallback) {
        syncBeginCallbacks.push(beginCallback)
    }
    if (endCallback) {
        syncEndCallbacks.push(endCallback)
    }
}

/**
 * Set the API URL prefix.
 * @alias qtoggle.api.base.setURLPrefix
 * @param {?String} prefix the URL prefix
 */
export function setURLPrefix(prefix) {
    apiURLPrefix = prefix
}

/**
 * Set the slave device for the next API call. If no argument or `null` is supplied, the API call will be requested on
 * the main device. Only the immediately following API request will be affected by this setting. Afterwards, the setting
 * will automatically revert to default (i.e. requesting to main device).
 * @alias qtoggle.api.base.setSlave
 * @param {?String} name the slave name
 */
export function setSlaveName(name) {
    /* If main device name is given, simply clear slave name */
    if (Cache.isMainDevice(name)) {
        name = null
    }

    slaveName = name || null
}

/**
 * Tell the name of the current slave device scheduled for the next API call.
 * @alias qtoggle.api.base.getSlave
 * @returns {?String} name the slave name or `null` if no slave is scheduled
 */
export function getSlaveName() {
    return slaveName
}


/**
 * Initialize the base API subsystem.
 * @alias qtoggle.api.base.init
 */
export function init() {
    setURLPrefix(Config.apiURLPrefix)
}
